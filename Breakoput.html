<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BREAKOPUT</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@600&display=swap');
  :root {
    --bg-color: #5a4e8c; /* darker pastel purple */
    --canvas-bg: rgba(90, 78, 140, 0.75); /* lighter transparent overlay */
  }
  html, body {
  margin: 0; height: 100%;
  background: linear-gradient(90deg, #4b3c82, #9b7de0);
  font-family: 'Poppins', sans-serif;
  display: flex; align-items: center; justify-content: center;
  color: #eee;
}
  #wrap {
  width: 700px; 
  padding: 20px;
  background: rgba(255, 182, 193, 0.12); /* light pink translucent */
  box-shadow: 10px 10px 20px rgba(0,0,0,0.15), inset 1px 1px 0.5px rgba(255,182,193,0.2);
  border-radius: 22px;
  backdrop-filter: blur(28px);
  -webkit-backdrop-filter: blur(28px);
  border: 1px solid rgba(255, 182, 193, 0.25);
  text-align: center;
}
  canvas {
    background: var(--canvas-bg);
    border-radius: 14px;
    display: block;
    margin: 0 auto;
    box-shadow: 0 8px 22px rgba(0,0,0,0.35);
  }
  #score {
    margin-top: 14px;
    font-size: 16px;
  }
  #legend {
    margin-top: 10px;
    color: #f0e8ff;
  }
  #controls {
    margin-top: 14px;
    display: flex;
    gap: 14px;
    justify-content: center;
    flex-wrap: wrap;
  }
  button {
    cursor: pointer;
    background: rgba(255,255,255,0.12);
    border: none;
    color: #fff;
    padding: 8px 16px;
    border-radius: 10px;
    font-weight: 600;
    min-width: 110px;
    transition: background-color 0.3s ease;
  }
  button.active {
    background: #f1c40f;
    color: #222;
  }
  #message {
    margin-top: 8px;
    padding: 8px 14px;
    background: rgba(0,0,0,0.6);
    border-radius: 8px;
    font-weight: 700;
    display: none;
  }
  @media(max-width: 740px){
    #wrap {
      width: 94vw;
    }
  }
</style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="640" height="480"></canvas>
    <div id="message"></div>
    <div id="score">Score: 0 | Lives: 3</div>
    <div id="legend">Move paddle with mouse. Restart: Click or Space.</div>
    <div id="controls">
      <button id="musicToggle" class="active">Music: ON</button>
      <button id="sfxToggle" class="active">SFX: ON</button>
      <button id="resetGame">Reset Game</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const msgEl = document.getElementById('message');
  const scoreEl = document.getElementById('score');
  const musicBtn = document.getElementById('musicToggle');
  const sfxBtn = document.getElementById('sfxToggle');
  const resetBtn = document.getElementById('resetGame');

  // Game constants
  const BALL_BASE_SPEED = 1.5;
  const BRICK_WIDTH = 60;
  const BRICK_HEIGHT = 20;
  const BRICK_PADDING = 10;
  const BRICK_TOP_OFFSET = 80;

  // Initial brick config
  let brickCols = 9;
  let brickRows = 5;

  // Game variables
  let bricks = [];
  let score = 0;
  let lives = 3;
  let running = false;

  // Paddle
  const paddle = {
    w: 100,
    h: 12,
    x: canvas.width / 2 - 50,
    y: canvas.height - 40,
    fill: '#ffb84d',
    stroke: '#e07b00',
  };

  // Ball
  const ball = {
    r: 8,
    x: canvas.width / 2,
    y: canvas.height - 60,
    dx: BALL_BASE_SPEED,
    dy: -BALL_BASE_SPEED,
    speed: BALL_BASE_SPEED,
  };

  // Audio Setup
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioCtx();

  const bgMusic = new Audio('https://cdn.pixabay.com/download/audio/2021/08/04/audio_8b238969b7.mp3?filename=lofi-beat-11726.mp3');
  bgMusic.loop = true;
  bgMusic.volume = 0.15;

  let musicOn = true;
  let sfxOn = true;
  let userInteracted = false;

  function startAudioOnInteraction() {
    if (userInteracted) return;
    userInteracted = true;
    if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => {});
    if (musicOn) bgMusic.play().catch(() => {});
  }
  document.addEventListener('click', startAudioOnInteraction, { once: true });
  document.addEventListener('keydown', startAudioOnInteraction, { once: true });

  function synth(type = 0, freq = 440, duration = 0.08, gain = 0.08) {
    if (!sfxOn) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = ['sine', 'triangle', 'sawtooth', 'square'][type % 4] || 'sine';
    o.frequency.value = freq;
    g.gain.value = gain;
    o.connect(g);
    g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    g.gain.setValueAtTime(gain, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + duration);
    o.start(now);
    o.stop(now + duration + 0.02);
  }

  function sfxPaddle() { synth(1, 880, 0.06, 0.09); }
  function sfxBrick() { synth(2, 520, 0.09, 0.09); synth(0, 740, 0.04, 0.04); }
  function sfxWall() { synth(0, 300, 0.06, 0.06); }
  function sfxGameOver() { synth(3, 120, 0.6, 0.18); }

  // Create bricks array
  function createBricks() {
    bricks = [];
    for (let c = 0; c < brickCols; c++) {
      bricks[c] = [];
      for (let r = 0; r < brickRows; r++) {
        bricks[c][r] = { x: 0, y: 0, status: 1 };
      }
    }
  }

  // Draw bricks
  function drawBricks() {
    const totalWidth = brickCols * (BRICK_WIDTH + BRICK_PADDING) - BRICK_PADDING;
    const offsetX = (canvas.width - totalWidth) / 2;
    for (let c = 0; c < brickCols; c++) {
      for (let r = 0; r < brickRows; r++) {
        if (bricks[c][r].status) {
          const bx = offsetX + c * (BRICK_WIDTH + BRICK_PADDING);
          const by = BRICK_TOP_OFFSET + r * (BRICK_HEIGHT + BRICK_PADDING);
          bricks[c][r].x = bx;
          bricks[c][r].y = by;
          ctx.fillStyle = `hsl(${r * 40 + c * 15}, 70%, 75%)`;
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          ctx.fillRect(bx, by, BRICK_WIDTH, BRICK_HEIGHT);
          ctx.strokeRect(bx, by, BRICK_WIDTH, BRICK_HEIGHT);
        }
      }
    }
  }

  // Draw paddle
  function drawPaddle() {
    ctx.fillStyle = paddle.fill;
    ctx.strokeStyle = paddle.stroke;
    ctx.lineWidth = 3;
    ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);
    ctx.strokeRect(paddle.x, paddle.y, paddle.w, paddle.h);
  }

  // Draw ball
  function drawBall() {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fillStyle = '#ffd75a';
    ctx.strokeStyle = '#e5b800';
    ctx.lineWidth = 2;
    ctx.fill();
    ctx.stroke();
    ctx.closePath();
  }

  // Draw score & lives
  function drawScore() {
    scoreEl.textContent = `Score: ${score} | Lives: ${lives}`;
  }

  // Draw title
  function drawTitle() {
    ctx.font = '48px Poppins, Arial';
    ctx.fillStyle = '#eee';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0,0,0,0.35)';
    ctx.shadowBlur = 10;
    ctx.fillText('Break Koput', canvas.width / 2, 50);
    ctx.shadowBlur = 0;
  }

  // Collision detection
  function collisionDetection() {
    let hitBrick = false;
    for (let c = 0; c < brickCols; c++) {
      for (let r = 0; r < brickRows; r++) {
        const b = bricks[c][r];
        if (b.status) {
          if (ball.x > b.x && ball.x < b.x + BRICK_WIDTH &&
              ball.y > b.y && ball.y < b.y + BRICK_HEIGHT) {
            ball.dy = -ball.dy;
            b.status = 0;
            score += 10;
            hitBrick = true;
            sfxBrick();
          }
        }
      }
    }
    if (hitBrick && isAllBricksCleared()) {
      increaseBricksDensity();
      createBricks();
      resetBall();
      showMessage('New wave! Keep going! Click or Space to continue.');
      running = false;
    }
  }

  function isAllBricksCleared() {
    for (let c = 0; c < brickCols; c++) {
      for (let r = 0; r < brickRows; r++) {
        if (bricks[c][r].status) return false;
      }
    }
    return true;
  }

  function increaseBricksDensity() {
    const maxCols = Math.floor((canvas.width + BRICK_PADDING) / (BRICK_WIDTH + BRICK_PADDING));
    const maxRows = Math.floor((canvas.height / 2) / (BRICK_HEIGHT + BRICK_PADDING));

    let newRows = brickRows * 2;
    if (newRows > maxRows) newRows = maxRows;

    let newCols = brickCols;
    if (newRows === maxRows) {
      newCols = brickCols * 2;
      if (newCols > maxCols) newCols = maxCols;
    }

    brickRows = newRows;
    brickCols = newCols;
  }

  // Reset ball and paddle positions and velocities
  function resetBall() {
    ball.x = canvas.width / 2;
    ball.y = canvas.height - 60;
    const angle = Math.PI / 4;
    const direction = Math.random() < 0.5 ? 1 : -1;
    ball.dx = BALL_BASE_SPEED * Math.cos(angle) * direction;
    ball.dy = -BALL_BASE_SPEED * Math.sin(angle);
    paddle.x = canvas.width / 2 - paddle.w / 2;
  }

  // Update game state
  function update() {
    if (!running) return;

    ball.x += ball.dx;
    ball.y += ball.dy;

    // Collisions with walls
    if (ball.x + ball.r > canvas.width) {
      ball.dx = -ball.dx;
      ball.x = canvas.width - ball.r;
      sfxWall();
    } else if (ball.x - ball.r < 0) {
      ball.dx = -ball.dx;
      ball.x = ball.r;
      sfxWall();
    }

    if (ball.y - ball.r < 0) {
      ball.dy = -ball.dy;
      ball.y = ball.r;
      sfxWall();
    } else if (ball.y + ball.r > canvas.height) {
      lives--;
      if (lives <= 0) {
        showMessage('Game Over! Reloading...');
        sfxGameOver();
        running = false;
        setTimeout(() => location.reload(), 1500);
        return;
      } else {
        resetBall();
      }
    }

    // Paddle collision with angle bounce
    if (ball.y + ball.r > paddle.y &&
        ball.x > paddle.x && ball.x < paddle.x + paddle.w) {
      const relative = ((ball.x - paddle.x) / paddle.w) * 2 - 1;
const bounceAngle = relative * (Math.PI / 3); // max 60deg
const speed = BALL_BASE_SPEED;  // keep constant speed here
ball.dx = speed * Math.sin(bounceAngle);
ball.dy = -speed * Math.cos(bounceAngle);
ball.y = paddle.y - ball.r - 0.1;
sfxPaddle();
 }

    collisionDetection();
  }

  // Draw all game elements
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawTitle();
    drawBricks();
    drawBall();
    drawPaddle();
    drawScore();
    if (running) update();
    requestAnimationFrame(draw);
  }

  // Mouse paddle control
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    paddle.x = Math.min(Math.max(mx - paddle.w / 2, 0), canvas.width - paddle.w);
  });

  // Restart game function
  function restartGame() {
    if (!running) {
      score = 0;
      lives = 3;
      running = true;
      brickCols = 9;
      brickRows = 5;
      createBricks();
      resetBall();
      hideMessage();
      draw();
    }
  }

  document.addEventListener('click', restartGame);
  document.addEventListener('keydown', e => {
    if (e.code === 'Space') restartGame();
  });

  // UI Button toggles
  musicBtn.addEventListener('click', () => {
    musicOn = !musicOn;
    if (musicOn) {
      bgMusic.play().catch(() => {});
      musicBtn.classList.add('active');
      musicBtn.textContent = 'Music: ON';
    } else {
      bgMusic.pause();
      musicBtn.classList.remove('active');
      musicBtn.textContent = 'Music: OFF';
    }
  });

  sfxBtn.addEventListener('click', () => {
    sfxOn = !sfxOn;
    if (sfxOn) {
      sfxBtn.classList.add('active');
      sfxBtn.textContent = 'SFX: ON';
    } else {
      sfxBtn.classList.remove('active');
      sfxBtn.textContent = 'SFX: OFF';
    }
  });

  resetBtn.addEventListener('click', () => {
    score = 0;
    lives = 3;
    running = true;
    brickCols = 9;
    brickRows = 5;
    createBricks();
    resetBall();
    hideMessage();
    draw();
  });

  // Show/hide messages
  function showMessage(text) {
    msgEl.style.display = 'block';
    msgEl.textContent = text;
  }
  function hideMessage() {
    msgEl.style.display = 'none';
  }

  // Initialize game
  createBricks();
  resetBall();
  draw();
})();
</script>
</body>
</html>
